import Foundation
import Swifter
import AVFoundation

class MockHLSServer {
    private let server = HttpServer()
    private var isRunning = false
    private var port: UInt16 = 0
    private let BASE_FOLDER: String
    
    init() {
        BASE_FOLDER = Self.findAssetsFolder()
        
        if #available(iOS 13.4, *) {
            setupRoutes()
        } else {
        }
    }
    
    private static func findAssetsFolder() -> String {
        let fileManager = FileManager.default
        
        // 1. Check bundle resources first (for bundled assets)
        if let bundlePath = Bundle.main.resourcePath {
            let bundleAssetsPath = "\(bundlePath)/assets"
            if fileManager.fileExists(atPath: bundleAssetsPath) {
                return bundleAssetsPath
            }
            
            // Check if renamed assets exist in bundle root (generated by asset scripts)
            let renamedFiles = ["seg_index.m3u8", "cmaf_video_index.m3u8", "multi_index.m3u8", "enc_index.m3u8"]
            let bundledFilesExist = renamedFiles.contains { 
                fileManager.fileExists(atPath: "\(bundlePath)/\($0)")
            }
            
            if bundledFilesExist {
                // Create dynamic assets folder structure from renamed files
                return createDynamicAssetsFolder(fromBundlePath: bundlePath)
            }
        }
        
        // 2. Check Documents directory (fallback for development)
        let documentsPath = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let docsAssetsPath = documentsPath.appendingPathComponent("assets").path
        if fileManager.fileExists(atPath: docsAssetsPath) {
            return docsAssetsPath
        }
        
        // 3. Check Cache directory (fallback)
        let cachePath = fileManager.urls(for: .cachesDirectory, in: .userDomainMask)[0]
        let cacheAssetsPath = cachePath.appendingPathComponent("test-assets").path
        if fileManager.fileExists(atPath: cacheAssetsPath) {
            return cacheAssetsPath
        }
        
        // 4. Final fallback: Documents directory
        return docsAssetsPath
    }
    
    private static func createDynamicAssetsFolder(fromBundlePath bundlePath: String) -> String {
        let fileManager = FileManager.default
        let tempPath = fileManager.temporaryDirectory.appendingPathComponent("dynamic-assets-\(UUID().uuidString)")
        let tempAssetsPath = tempPath.path
        
        do {
            // Create temp directory structure
            try fileManager.createDirectory(atPath: tempAssetsPath, withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/segments", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/cmaf", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/cmaf/video", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/cmaf/audio", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/multivariant", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/multivariant/240p", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/multivariant/360p", withIntermediateDirectories: true)
            try fileManager.createDirectory(atPath: "\(tempAssetsPath)/encrypted", withIntermediateDirectories: true)
            
            // Map renamed files back to original structure
            let fileMappings: [(from: String, to: String)] = [
                // Segments
                ("seg_index.m3u8", "segments/index.m3u8"),
                ("seg_0.ts", "segments/0.ts"),
                ("seg_1.ts", "segments/1.ts"),
                ("seg_2.ts", "segments/2.ts"),
                ("seg_3.ts", "segments/3.ts"),
                
                // CMAF Video
                ("cmaf_video_index.m3u8", "cmaf/video/index.m3u8"),
                ("cmaf_video_0.m4s", "cmaf/video/0.m4s"),
                ("cmaf_video_1.m4s", "cmaf/video/1.m4s"),
                ("cmaf_video_2.m4s", "cmaf/video/2.m4s"),
                ("cmaf_video_3.m4s", "cmaf/video/3.m4s"),
                ("video_init.mp4", "cmaf/video/init.mp4"),
                
                // CMAF Audio
                ("cmaf_audio_index.m3u8", "cmaf/audio/index.m3u8"),
                ("cmaf_audio_0.m4s", "cmaf/audio/0.m4s"),
                ("cmaf_audio_1.m4s", "cmaf/audio/1.m4s"),
                ("cmaf_audio_2.m4s", "cmaf/audio/2.m4s"),
                ("cmaf_audio_3.m4s", "cmaf/audio/3.m4s"),
                ("cmaf_audio_4.m4s", "cmaf/audio/4.m4s"),
                ("audio_init.mp4", "cmaf/audio/init.mp4"),
                
                // Main CMAF playlist
                ("index_cmaf.m3u8", "cmaf/index.m3u8"),
                
                // Input files
                ("input_240p.mp4", "input_240p.mp4"),
                ("input_360p.mp4", "input_360p.mp4"),
                
                // Multivariant
                ("multi_index.m3u8", "multivariant/index.m3u8"),
                ("multi_240p_index.m3u8", "multivariant/240p/index.m3u8"),
                ("multi_240p_0.ts", "multivariant/240p/0.ts"),
                ("multi_240p_1.ts", "multivariant/240p/1.ts"),
                ("multi_240p_2.ts", "multivariant/240p/2.ts"),
                ("multi_240p_3.ts", "multivariant/240p/3.ts"),
                ("multi_360p_index.m3u8", "multivariant/360p/index.m3u8"),
                ("multi_360p_0.ts", "multivariant/360p/0.ts"),
                ("multi_360p_1.ts", "multivariant/360p/1.ts"),
                ("multi_360p_2.ts", "multivariant/360p/2.ts"),
                ("multi_360p_3.ts", "multivariant/360p/3.ts"),
                
                // Encrypted
                ("enc_index.m3u8", "encrypted/index.m3u8"),
                ("enc_0.ts", "encrypted/0.ts"),
                ("enc_1.ts", "encrypted/1.ts"),
                ("enc_2.ts", "encrypted/2.ts"),
                ("enc_3.ts", "encrypted/3.ts"),
            ]
            
            // Copy files from bundle to expected locations
            for (fromFile, toPath) in fileMappings {
                let sourcePath = "\(bundlePath)/\(fromFile)"
                let destPath = "\(tempAssetsPath)/\(toPath)"
                
                if fileManager.fileExists(atPath: sourcePath) {
                    try fileManager.copyItem(atPath: sourcePath, toPath: destPath)
                }
            }
            
            return tempAssetsPath
            
        } catch {
            print("Failed to create dynamic assets folder: \(error)")
            // Fallback to Documents
            let documentsPath = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
            return documentsPath.appendingPathComponent("assets").path
        }
    }
    
    var baseURL: String {
        return "http://localhost:\(port)"
    }
    
    func start() throws {
        port = UInt16.random(in: 8080...9000)
        try server.start(port)
        isRunning = true
    }
    
    func stop() {
        server.stop()
        isRunning = false
    }
    
  
    @available(iOS 13.4, *)
    private func setupRoutes() {
        
        server.GET["/health"] = { [weak self] request, _ in
            guard let _ = self else { return .internalServerError() }
            return HttpResponse.ok(.text("OK"))
        }
        
        server.GET["/sanity-check"] = { [weak self] request, _ in
            guard let _ = self else { return .internalServerError() }
            return HttpResponse.ok(.text("Works!"))
        }
        server.GET["/sanity-check/**"] = { [weak self] request, _ in
            guard let _ = self else { return .internalServerError() }
            return HttpResponse.ok(.text("Works!"))
        }
        
        // Serve files directly from assets folder
        server["/**"] = { [weak self] request, _ in
            guard let self = self else { return .internalServerError() }
            
            // Skip if it's a specific route handled elsewhere
            if request.path.hasPrefix("/health") ||
               request.path.hasPrefix("/sanity-check") ||
               request.path.hasPrefix("/normal/") ||
               request.path.hasPrefix("/not-found/") ||
               request.path.hasPrefix("/proxy/") ||
               request.path.contains("-playlist.m3u8") {
                return .notFound()
            }
            
            let safePath = request.path
                .trimmingCharacters(in: CharacterSet(charactersIn: "/"))
                .split(separator: "/")
                .filter { !$0.contains("..") }
                .joined(separator: "/")
            
            let filePath = "\(self.BASE_FOLDER)/\(safePath)"
            
            if let fileHandle = FileHandle(forReadingAtPath: filePath) {
                let fileData = try! fileHandle.readToEnd() ?? Data()
                
                let pathExtension = URL(fileURLWithPath: safePath).pathExtension
                let contentType = self.mimeType(forFileExtension: pathExtension)
                
                return .ok(.data(fileData, contentType: contentType))
            } else {
                return HttpResponse.notFound()
            }
        }
        
        
        server["/normal/**"] = { [weak self] request, _ in
            guard let self = self else { return .internalServerError() }
            
            let fullPath = request.path.replacingOccurrences(of: "/normal/", with: "")
            
            let safePath = fullPath
                .split(separator: "/")
                .filter { !$0.contains("..") }
                .joined(separator: "/")
            
            let filePath = "\(self.BASE_FOLDER)/\(safePath)"
            
            if let fileHandle = FileHandle(forReadingAtPath: filePath) {
                let fileData = try! fileHandle.readToEnd() ?? Data()
                
                let contentType: String
                if safePath.hasSuffix(".m3u8") {
                    contentType = "application/vnd.apple.mpegurl"
                } else if safePath.hasSuffix(".ts") {
                    contentType = "video/mp2t"
                } else if safePath.hasSuffix(".m4s") {
                    contentType = "video/iso.segment"
                } else if safePath.hasSuffix(".mp4") {
                    contentType = "video/mp4"
                } else {
                    contentType = "application/octet-stream"
                }
                
                return .ok(.data(fileData, contentType: contentType))
            } else {
                return HttpResponse.notFound()
            }
        }
        
        server["/not-found/:segment"] = { request, _ in
            return HttpResponse.notFound()
        }
        
        // Playlist endpoints that use normal (working) segments
        server.GET["/normal-playlist.m3u8"] = { [weak self] request, _ in
            guard let self = self else { return .internalServerError() }
            let content = self.normalVariantPlaylist(quality: "normal")
            return .ok(.text(content))
        }
        
        // Playlist endpoints that use failing segments
        server.GET["/failing-playlist.m3u8"] = { [weak self] request, _ in
            guard let self = self else { return .internalServerError() }
            let content = self.failingVariantPlaylist(quality: "failing")
            return .ok(.text(content))
        }
        
        server.GET["/proxy/:proxyPath"] = { request, _ in
            let proxyPath = request.params[":proxyPath"] ?? ""
            
            guard let proxyHost = request.queryParams.first(where: { $0.0 == "proxyHost" })?.1 else {
                return .badRequest(.text("Missing proxyHost parameter"))
            }
            
            let targetURL = "https://\(proxyHost)/\(proxyPath)"
            guard let url = URL(string: targetURL) else {
                return .badRequest(.text("Invalid target URL"))
            }
            
            let semaphore = DispatchSemaphore(value: 0)
            let resultContainer = NSMutableArray()
            
            URLSession.shared.dataTask(with: url) { data, response, error in
                defer { semaphore.signal() }
                
                let httpResponse: HttpResponse
                
                if let _ = error {
                    httpResponse = .internalServerError()
                } else if let httpResp = response as? HTTPURLResponse,
                          let data = data {
                    
                    if httpResp.statusCode == 200 {
                        let contentType = httpResp.allHeaderFields["Content-Type"] as? String ?? "application/octet-stream"
                        
                        if contentType.contains("text") || contentType.contains("application/vnd.apple.mpegurl") {
                            if let textContent = String(data: data, encoding: .utf8) {
                                httpResponse = .ok(.text(textContent))
                            } else {
                                httpResponse = .ok(.data(data))
                            }
                        } else {
                            httpResponse = .ok(.data(data))
                        }
                    } else {
                        switch httpResp.statusCode {
                        case 404: httpResponse = .notFound()
                        case 500: httpResponse = .internalServerError()
                        case 400: httpResponse = .badRequest(.text("HTTP Error \(httpResp.statusCode)"))
                        default: httpResponse = .internalServerError()
                        }
                    }
                } else {
                    httpResponse = .internalServerError()
                }
                
                resultContainer.add(httpResponse)
            }.resume()
            
            let timeout = DispatchTime.now() + .seconds(10)
            if semaphore.wait(timeout: timeout) == .timedOut {
                return .internalServerError()
            }
            
            return resultContainer.firstObject as? HttpResponse ?? .internalServerError()
        }
    }
    
    // Generate playlist with segments that will work
    private func normalVariantPlaylist(quality: String) -> String {
        let segments = (0..<10).map { i in
            "#EXTINF:10.0,\n\(baseURL)/normal/segment\(i).ts"
        }.joined(separator: "\n")
        
        return """
        #EXTM3U
        #EXT-X-VERSION:3
        #EXT-X-TARGETDURATION:10
        #EXT-X-MEDIA-SEQUENCE:0
        \(segments)
        #EXT-X-ENDLIST
        """
    }
    
    // Generate playlist with segments that will fail
    private func failingVariantPlaylist(quality: String) -> String {
        let segments = (0..<10).map { i in
            "#EXTINF:10.0,\n\(baseURL)/not-found/segment\(i).ts"
        }.joined(separator: "\n")
        
        return """
        #EXTM3U
        #EXT-X-VERSION:3
        #EXT-X-TARGETDURATION:10
        #EXT-X-MEDIA-SEQUENCE:0
        \(segments)
        #EXT-X-ENDLIST
        """
    }
    
    private func mimeType(forFileExtension ext: String) -> String {
        switch ext {
        case "m3u8": return "application/vnd.apple.mpegurl"
        case "ts": return "video/mp2t"
        case "m4s": return "video/iso.segment"
        case "mp4": return "video/mp4"
        default: return "application/octet-stream"
        }
    }
}

// MARK: - Test Helper Extensions
extension MockHLSServer {
    func forPath(_ path: String) -> String {
        return "\(baseURL)/\(path)"
    }
    
    // Get URL for fatal error testing
    var errorURL: String {
        return "\(baseURL)/error/404.m3u8"
    }
    
    // Playlist with segments that will work (return 200)
    var normalSegmentsURL: String {
        return "\(baseURL)/normal-playlist.m3u8"
    }
    
    // Playlist with segments that will fail (return 404)
    var failingSegmentsURL: String {
        return "\(baseURL)/failing-playlist.m3u8"
    }
    
    // Direct segment URLs for testing
    func normalSegmentURL(_ segmentName: String) -> String {
        return "\(baseURL)/normal/\(segmentName)"
    }
    
    func failingSegmentURL(_ segmentName: String) -> String {
        return "\(baseURL)/not-found/\(segmentName)"
    }
    
    // Proxy URL helper
    func proxyURL(path: String, host: String) -> String {
        return "\(baseURL)/proxy/\(path)?proxyHost=\(host)"
    }
    
    // Debug helper to expose findAssetsFolder for testing
    static func debugFindAssetsFolder() -> String {
        return findAssetsFolder()
    }
}
